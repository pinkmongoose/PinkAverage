#' @include PinkAverage-package.r
 
#' @rdname make_iterated_mean
#' @title Create iterated mean function
#' @description Create an iterated mean function to apply to two numbers, using a function factory. For an iterated mean, two functions `FUN1` and `FUN2` are applied to the pair of numbers, producing a new pair of numbers, and the process repeated until convergence.
#' @param FUN1,FUN2 The functions to apply.
#' @param tol The tolerance required before convergence is considered achieved.
#' @return A function with parameters `(x, y)` to calculate an iterated mean.
#' @details For repeat use use associated factory function and apply it, rather than the single-function-call equivalent. 
#' @examples 
#' agmean <- make_iterated_mean(\(i,j) (i+j)/2, \(i,j) sqrt(i*j))
#' agmean(1,2)
#' @family iterated means
#' @family bivariate means
#' @export
make_iterated_mean <- function(FUN1, FUN2, tol=.Machine$double.eps^0.5) function(x, y) {
  while (abs(x-y)>tol) {
    x <- FUN1(x,y)
    y <- FUN2(x,y)
  }
  (x+y)/2
}

#' @rdname make_iterated_mean
#' @param x,y The numbers to calculate the mean of.
#' @return The iterated mean.
#' @examples 
#' 
#' iterated_mean(iterated_mean(1 ,2, \(i,j) (i+j)/2, \(i,j) sqrt(i*j)))
#' @export
iterated_mean <- function(x, y, FUN1, FUN2, tol=.Machine$double.eps^0.5) make_iterated_mean(FUN1,FUN2,tol)(x,y)

#' @rdname arithmetic_mean2
#' @title Bivariate mean helper functions
#' @description Helper functions for use in iterated means, to calculate simple means with two numeric parameters.
#' @param x,y The numbers to calculate the mean of.
#' @return The arithmetic mean.
#' @examples 
#' arithmetic_mean2(1,2)
#' @family iterated means
#' @family bivariate means
#' @export
arithmetic_mean2 <- function(x, y) (x+y)/2

#' @rdname arithmetic_mean2
#' @return The geometric mean.
geometric_mean2 <- function(x, y) sqrt(x*y)

#' @rdname arithmetic_mean2
#' @return The harmonic mean.
harmonic_mean2 <- function(x, y) 2/(1/x+1/y)

#' @rdname arithmetic_mean2
#' @return The contraharmonic mean.
contraharmonic_mean2 <- function(x, y) (x*x+y*y)/(x+y)

#' Iterated mean functions
#'
#' Calculate the iterated means of two numbers, using functions generated by the function factory `make_iterated_mean`.
#' @param x,y The numbers to calculate the mean of.
#' @return The arithmetic-geometric mean.
#' @examples 
#' arithmetic_geometric_mean(1,2)
#' @family iterated means
#' @family bivariate means
#' @references 
#' Weisstein, Eric W. (accessed 2023) Arithmetic-Geometric Mean. From MathWorld--A Wolfram Web Resource. https://mathworld.wolfram.com/Arithmetic-GeometricMean.html
#' @export
arithmetic_geometric_mean <- make_iterated_mean(arithmetic_mean2, geometric_mean2)

#' @rdname arithmetic_geometric_mean
#' @return The geometric-harmonic mean.
#' @examples 
#' geometric_harmonic_mean(1,2)
#' @references Weisstein, Eric W. (accessed 2023) Arithmetic-Harmonic Mean. From MathWorld--A Wolfram Web Resource. https://mathworld.wolfram.com/Arithmetic-HarmonicMean.html
#' @export
geometric_harmonic_mean <- make_iterated_mean(geometric_mean2, harmonic_mean2)

#' Heronian mean
#'
#' Calculate the Heronian mean, which is for two numbers `x` and `y` equal to \eqn{\frac{1}{3}(x+y+\sqrt{xy})}.
#' @param x,y The numbers to calculate the mean of.
#' @return The Heronian mean.
#' @examples 
#' Heronian_mean(1,2)
#' @family bivariate means
#' @references 
#' Bullen, P.S. (2003). 2.1.4 Heronian, centroidal and neo-Pythagorean means, Handbook of Means and Their Inequalities. Mathematics and Its Applications, Berlin, New York: Springer Science+Business Media, pp. 399–401, doi:10.1007/978-94-017-0399-4, ISBN 978-1-4020-1522-9.
#' @export
Heronian_mean <- function(x, y) (x + y + sqrt(x*y))/3

#' Logarithmic mean
#' 
#' Calculate the logarithmic mean of two numbers, not to be confused with the geometric mean calculated by `geometric_mean2`.
#' @param x,y The numbers to calculate the mean of.
#' @return The logarithmic mean.
#' @examples 
#' logarithmic_mean(1,2)
#' @family bivariate means
#' @references 
#' Tung-Po Lin (1974). The Power Mean and the Logarithmic Mean. The American Mathematical Monthly, 81: 879–883. doi:10.1080/00029890.1974.11993684.
#' @export
logarithmic_mean <- function(x, y) ifelse(x==y, x, (x-y)/(log(x)-log(y)))

#' Identric mean
#' 
#' Calculate the identric mean of two numbers.
#' @param x,y The numbers to calculate the mean of.
#' @return The identric mean.
#' @examples 
#' identric_mean(1,2)
#' @family bivariate means
#' @references 
#' Alzer, H. (1993). Some Gamma Function Inequalities." Mathematics of Computation, 60, 337-346.
#' 
#' Bullen, P. S., Mitrinović, D. S., and Vasić, P. M. (1988). Means and Their Inequalities. Dordrecht, Netherlands: Reidel.
#' @export
identric_mean <- function(x, y) ifelse(x==y, x, exp(-1)*((x^x)/(y^y))^(1/(x-y)))

#' Stolarsky mean
#' 
#' Create a Stolarsky mean function to apply to two numbers, using a function factory. For a power `p`, the Stolarsky mean interpolates between certain other means such as the geometric mean (`p==-1`) and the arithmetic mean (`p==2`) for two numbers.
#' @param p The power for the mean.
#' @return A function with two parameters `(x,y)` to calculate a Stolarsky mean, except for the following cases. For `p==-Inf` the `min` function is returned. For `p==-1` the `geometric_mean2` function is returned. For `p==0` the `logarithmic_mean` function is returned. For `p==1` the `identric_mean` function is returned. For `p==2` the `arithmetic_mean2` function is returned. For `p==Inf` the `max` function is returned.
#' @details For repeat use use associated factory function and apply it, rather than the single-function-call equivalent. 
#' @examples 
#' sm <- make_Stolarsky_mean(2.5)
#' sm(1,2)
#' @family bivariate means
#' @references
#' Stolarsky, Kenneth B. (1975). Generalizations of the logarithmic mean. Mathematics Magazine, 48: 87–92. doi:10.2307/2689825.
#' @export
make_Stolarsky_mean <- function(p) {
  if (p==-Inf) return(min)
  else if (p==-1) return(geometric_mean2)
  else if (p==0) return(logarithmic_mean)
  else if (p==1) return(identric_mean)
  else if (p==2) return(arithmetic_mean2)
  else if (p==Inf) return(max)
  function(x, y) ifelse(x==y, x, ((x^p-y^p)/(p*(x-y)))^(1/(p-1)))
}

#' @rdname make_Stolarsky_mean
#' @param x,y The numbers to calculate the mean of.
#' @return A Stolarsky mean.
#' @examples 
#' 
#' Stolarsky_mean(1,2,2.5)
#' @export
Stolarsky_mean <- function(x,y,p) make_Stolarsky_mean(p)(x,y)

#' Heinz mean
#' 
#' Create a Heinz mean function to apply to two numbers, using a function factory. For a power `p`, the Heinz mean interpolates between the arithmetic (`p==0`) and geometric means (`p==0.5`) for two numbers.
#' @param p The power for the mean.
#' @return A function with parameters `(x,y)` to calculate a Heinz mean, except for the following cases. For `p==0` the `arithmetic_mean2` function is returned. For `p==0.5` the `geometric_mean2` function is returned.
#' @details For repeat use use associated factory function and apply it, rather than the single-function-call equivalent. 
#' @examples 
#' hm <- make_Heinz_mean(0.25)
#' hm(1,2)
#' @family bivariate means
#' @references
#' Bhatia, R. (2006). Interpolating the arithmetic-geometric mean inequality and its operator version. Linear Algebra and Its Applications, 413: 355–363. doi:10.1016/j.laa.2005.03.005.
#' @export
make_Heinz_mean <- function(p) {
  if (p==0) return(arithmetic_mean2)
  else if (p==0.5) return(geometric_mean2)
  function(x, y) (x^p*y^(1-p) + y^p*x^(1-p))/2
} 

#' @rdname make_Heinz_mean
#' @param x,y The numbers to calculate the mean of.
#' @return A Heinz mean.
#' @examples 
#' 
#' Heinz_mean(1,2,0.25)
#' @export
Heinz_mean <- function(x,y,p) make_Heinz_mean(p)(x,y)

#' Seiffert-like mean
#' 
#' Create a Seiffert-like mean function to apply to two numbers, using a function factory. For a function `FUN`, the Seiffert-like means include functions such as the arithmetic mean (`FUN=identity`), Neuman-Sandor mean (`FUN=asinh`), logarithmic mean (`FUN=atanh`) and Seiffert means (`FUN=asin` and `FUN=atan`).
#' @param FUN The positive function for the mean.
#' @return A function with parameters `(x,y)` to calculate a Seiffert-like mean.
#' @details For repeat use use associated factory function and apply it, rather than the single-function-call equivalent. 
#' @examples 
#' ns <- make_Seiffert_like_mean(asinh)
#' ns(1,2)
#' @family bivariate means
#' @references 
#' Neuman, E & Sándor, J (2003). On the Schwab–Borchardt mean, Mathetica Pannonica 14: 253–266.
#'
#' Witkowski, A (2015). On Seiffert-like means. Journal of Mathematical Inequalities 9: 1071-1092.
#' @export
make_Seiffert_like_mean <- function(FUN) function(x,y) ifelse(x==y, x, abs(x-y)/(2*FUN(abs(x-y)/(x+y))))

#' @rdname make_Seiffert_like_mean
#' @param x,y The numbers to calculate the mean of.
#' @return A Seiffert-like mean.
#' @examples 
#' 
#' Seiffert_like_mean(1,2,asinh)
#' @export
Seiffert_like_mean <- function(x,y,FUN) make_Seiffert_like_mean(FUN)(x,y)

#' @rdname make_Seiffert_like_mean
#' @examples 

#' Neuman_Sandor(1,2)
#' @export
Neuman_Sandor <- make_Seiffert_like_mean(asinh)

#' @rdname make_Seiffert_like_mean
#' @examples 
#' 
#' first_Seiffert(1,2)
#' @export
first_Seiffert <- make_Seiffert_like_mean(asin)

#' @rdname make_Seiffert_like_mean
#' @examples 
#'
#' second_Seiffert(1,2)
#' @export
second_Seiffert <- make_Seiffert_like_mean(atan)
